Вот обновленный вариант текстов для слайдов. Я усилил технические описания и добавил конкретные указания по инфографике и схемам там, где текста было мало или требовалась визуализация сложных процессов.

Раздел 1: Введение и Обзор Технологий (Слайды 1-5)

Слайд 1: Титульный

Заголовок: Teamly — Коллаборативный трекер задач

Подзаголовок: Архитектура MVP, реализация Kanban-доски и технические решения.

Текст:

Проект разработан как SPA (Single Page Application) для управления задачами в малых группах.

Основной фокус разработки: производительность рендеринга, строгая типизация и модульность кода.

Реализован полный цикл CRUD, безопасная аутентификация и real-time взаимодействие через polling (MVP).

Приложение спроектировано с учетом принципов "Desktop-first", но полностью адаптивно.

Слайд 2: Проблематика и Постановка задачи

Существующие Enterprise-решения (например, Jira) функционально избыточны для семейных и волонтерских команд.

Требуется инструмент с "нулевым" порогом входа, работающий без сложной настройки воркфлоу.

Необходима строгая изоляция данных: пользователь видит только те доски, куда он приглашен.

Архитектура должна поддерживать масштабирование функционала без переписывания ядра.

[ИНФОГРАФИКА: Сравнение] Таблица сравнения: "Enterprise (Jira)" vs "Teamly". Критерии: Скорость загрузки, Сложность интерфейса, Настройка прав.

Слайд 3: Технический стек (Frontend)

Core: Nuxt 3.17 + Vue 3.5 (использование Composition API и <script setup>).

State Management: Pinia + pinia-plugin-persistedstate для сохранения состояния между сессиями.

UI Engine: Нативные CSS Variables для темизации + UnoCSS (подключен через слои).

Drag-and-Drop: Библиотека @formkit/drag-and-drop — минимальный вес бандла.

[ИНФОГРАФИКА: Логотипы] Ряд логотипов технологий: Vue, Nuxt, Pinia, TypeScript, UnoCSS.

Слайд 4: Технический стек (Backend & Data)

Server Engine: Nitro — легковесный сервер, встроенный в Nuxt, с поддержкой экспериментального OpenAPI.

Database: PostgreSQL 16 (в Docker-образе postgres:16-alpine).

ORM: Prisma Client 6.10 для типобезопасных запросов к БД.

Auth: Lucia Auth (v3) — управление сессиями без использования JWT.

[ИНФОГРАФИКА: Стек] Схема взаимодействия: Client -> Nitro Server -> Prisma Client -> PostgreSQL Container.

Слайд 5: Инфраструктура и Dev-окружение

Проект полностью контейнеризирован с помощью Docker Compose.

Оркестрация двух сервисов: app (Nuxt-приложение) и db (PostgreSQL).

Настроен healthcheck для БД: приложение ожидает готовности порта 5432 перед запуском.

Используется multi-stage сборка в Dockerfile для минимизации production-образа (на базе Alpine Linux).

[ИНФОГРАФИКА: Docker Flow] Схема контейнеров: app (порт 3000) <---> внутренняя сеть tracker-net <---> db (порт 5432).

Раздел 2: Архитектура приложения (Слайды 6-9)

Слайд 6: Модульная архитектура (Nuxt Layers)

Вместо монолита используется архитектура Nuxt Layers для слабого зацепления кода.

Слой layers/core: базовые UI-атомы, глобальные стили и утилиты.

Слой layers/auth: изолированная логика регистрации и сессий.

Слой layers/board: бизнес-логика Kanban-доски.

Слой layers/tasks: управление сущностями задач.

[ИНФОГРАФИКА: Структура] Визуализация "слоеного пирога": Base App <- Core <- Auth <- Board <- Tasks.

Слайд 7: Схема Базы Данных (ER-Model)

Центральные сущности: User, Board, Task.

Связи построены на внешних ключах с каскадным удалением (onDelete: Cascade).

TaskStatus в MVP реализован как Enum для упрощения логики перемещения.

[ИНФОГРАФИКА: ER-диаграмма] Упрощенная схема БД: User (1:N) -> Board (1:N) -> Task. Связь M:N через BoardParticipant.

Слайд 8: Ролевая модель доступа (RBAC)

Права доступа жестко типизированы через enum BoardRole в Prisma.

Owner: Полный доступ, удаление доски, управление приглашениями.

Editor: Создание, редактирование контента, перемещение задач.

Viewer: Только чтение (Read-only доступ).

[ТАБЛИЦА: Матрица доступа] Строки: Роли. Столбцы: Создание задач, Удаление задач, Перемещение, Настройки доски. Галочки/крестики.

Слайд 9: Реализация Аутентификации

Используется библиотека Lucia Auth (адаптер Prisma).

Отход от stateless JWT в пользу stateful sessions в БД (таблица Session).

Это позволяет администратору принудительно отзывать сессии (разлогинивать пользователей).

Пароли хешируются алгоритмом Argon2 перед записью в базу.

[ИНФОГРАФИКА: Sequence Diagram] Диаграмма последовательности: Post Login -> Validate -> Create Session in DB -> Set Cookie -> Response.

Раздел 3: Реализация Kanban-доски (Слайды 10-20)

Слайд 10: Модель данных Kanban

Статусы задач зафиксированы: todo, in_progress, done.

Это решение принято для MVP, чтобы избежать сложности управления динамическими колонками.

Поле order_index зарезервировано для пользовательской сортировки (vNext).

Призма-модель:
[ВСТАВИТЬ КУСОК КОДА из schema.prisma]

code
Prisma
download
content_copy
expand_less
enum TaskStatusEnum {
todo
in_progress
done
}
model Task {
status TaskStatusEnum @default(todo)
// ...
}

Слайд 11: Управление состоянием (Pinia Store)

Стор kanban.store.ts — единый источник правды для UI доски.

Состояние columns хранит массив объектов колонок, каждая содержит массив задач.

Инициализация: метод fetch() делает запрос к API и раскладывает плоский массив задач по статусам.

[ИНФОГРАФИКА: State Flow] Схема: Raw Data (Backend) -> fetch() -> Transformation Logic -> Pinia State (Columns Array) -> UI Component.

Слайд 12: Серверная логика выборки данных

Эндпоинт: GET /api/board/:id/tasks.

Шаг 1: Проверка сессии пользователя (getUserFromSession).

Шаг 2: Проверка доступа к доске (является ли участником или владельцем).

Шаг 3: Выборка задач с include для подгрузки данных исполнителей.

[ИНФОГРАФИКА: Блок-схема] Алгоритм: Request -> Auth Check -> ACL Check -> DB Query -> Response / Error 403.

Слайд 13: Drag-and-Drop (Frontend)

Реализация на базе @formkit/drag-and-drop.

Компонент kanban-column.vue выступает как дроп-зона.

Используется реактивная привязка: изменение DOM автоматически обновляет массив dndTasks.

Обработчик onTransfer фиксирует факт переноса задачи между списками.

Слайд 14: Optimistic UI (Оптимистичные обновления)

Мгновенная реакция интерфейса до получения ответа от сервера.

При событии dragend задача перемещается в локальном сторе.

Фоново отправляется PATCH запрос. Если он падает — состояние откатывается.
[ВСТАВИТЬ КУСОК КОДА из kanban.store.ts]

code
TypeScript
download
content_copy
expand_less
// 1. Локально меняем UI
const task = this.findAndRemoveTask(taskId);
this.columns.find(c => c.id === toStatus).tasks.push(task);
// 2. Шлем запрос
await $fetch(...)
// 3. При ошибке - откат (catch block)

Слайд 15: Компонент Колонки (kanban-column.vue)

Отвечает за рендеринг вертикального списка карточек.

Принимает проп column с данными (id, title, tasks).

Содержит встроенный input для быстрого создания задач без модальных окон.

Визуально разделен с помощью CSS Grid и псевдоэлементов ::before (вертикальные линии).

Слайд 16: API создания задачи

Метод: POST /api/task.

Валидация тела запроса через Zod (TaskCreateSchema).

Автоматическая привязка статуса todo.

Связывание с доской через board_id.

[ИНФОГРАФИКА: Data Shape] JSON-структура запроса: { title: string, description?: string, priority: enum, board_id: uuid }.

Слайд 17: API обновления (PATCH)

Универсальный эндпоинт PATCH /api/task/[id] для любых изменений.

Поддерживает частичное обновление (Partial Update).

Используется как для смены текста задачи, так и для переключения статуса (status).

Призма автоматически обновляет поле updated_at.

Слайд 18: Карточка задачи (task-card.vue)

Атомарный компонент отображения задачи.

Выводит ID (например, #a3f1), заголовок и бейджи.

Интегрирует компонент PriorityBadge для цветовой кодировки.

Отображает количество исполнителей ("+2 исп.").

[ИНФОГРАФИКА: Анатомия карточки] Скриншот карточки с выносками: "ID", "Priority Icon", "Title", "Assignees count", "Date".

Слайд 19: Система приоритетов

Три уровня приоритета: Low, Medium, High.

Реализовано через компонент priority-badge.vue.

Использует семантические цвета дизайн-системы:

High -> Error Container (Красный).

Medium -> Primary Container (Синий).

Low -> Secondary Container (Серый).

Слайд 20: Работа с датами и локализация

Используется библиотека date-fns для легковесной обработки дат.

Функция formatDistanceToNow создает человекочитаемые строки ("5 минут назад").

Подключена локаль ru для корректных склонений.

Это повышает информативность интерфейса без перегрузки точными датами.

Раздел 4: Дополнительные функции (Слайды 21-25)

Слайд 21: Реализация Чата (MVP)

Чат привязан к конкретной доске (Board -> Conversation -> Message).

Вместо WebSockets используется Short Polling (опрос раз в 5 сек).

Это упрощает деплоймент и инфраструктуру на старте проекта.

Поддержка упоминаний @all (реализовано регулярным выражением на бэкенде).

[ИНФОГРАФИКА: Polling Loop] Схема цикла: Client --(GET /chat)--> Server; (wait 5s); Client --(GET /chat)--> Server.

Слайд 22: Приглашения и QR-коды

Таблица InvitationLink хранит токены доступа.

Параметры ссылки: роль (viewer/editor), лимит использований, срок действия.

Генерация QR-кода происходит на клиенте с помощью qrcode.vue.

Удобно для быстрого подключения мобильных устройств к доске.

Слайд 23: Регистрация и Онбординг

Форма регистрации валидируется на клиенте и сервере.

Автоматическая генерация display_name из email, если поле не заполнено.

UX-паттерн: автоматический вход (создание сессии) сразу после регистрации.

Пользователю не нужно вводить логин/пароль повторно.

Слайд 24: Дизайн-система и Токены

Используются CSS Custom Properties для глобальной настройки.

Определены токены для: цветов (--clr-primary), отступов (--sp-m), скруглений (--cr-l).

Базовые компоненты (TeamlyButton, TeamlyInput) строятся на этих токенах.

[ИНФОГРАФИКА: Палитра] Визуализация цветовой палитры (Light/Dark mode) и шкалы отступов.

Слайд 25: Адаптивность и Layout

Используется CSS Grid для каркаса страницы (layout.css).

Переменные брейкпоинтов: --bp-m: 768px.

Сайдбары имеют фиксированную ширину на десктопе, на мобильных скрываются.

Основной контент (доска) имеет горизонтальный скролл на малых экранах.

Раздел 5: Безопасность и Развертывание (Слайды 26-28)

Слайд 26: Валидация данных (Zod)

Используется библиотека Zod для декларирования схем данных.

Валидация происходит в API-хендлерах перед обращением к БД.

Гарантирует, что в базу попадут только корректные типы данных.
[ВСТАВИТЬ КУСОК КОДА из api/board/index.post.ts]

code
TypeScript
download
content_copy
expand_less
const BoardCreateSchema = z.object({
title: z.string().min(1).max(120),
visibility: z.enum(["private", "link", "public"]),
});
// parsed.data используется дальше

Слайд 27: Защита и Middleware

Клиент: Глобальный middleware проверяет состояние авторизации.

Сервер: Утилита getUserFromSession(event) извлекает пользователя из cookie.

ACL: Проверка прав доступа к ресурсу (например, проверка owner_user_id при удалении доски).

При отсутствии прав возвращается стандартный 403 Forbidden.

Слайд 28: Docker Compose Конфигурация

Файл docker-compose.yml описывает сервисы.

Сервис app: сборка из Dockerfile, проброс порта 3000.

Сервис db: официальный образ postgres:16-alpine.

Использование depends_on с condition: service_healthy для правильного порядка запуска.

[ИНФОГРАФИКА: Container Architecture] Схема: Host Machine -> Docker Engine -> [App Container] + [DB Container] (Volume).

Раздел 6: Заключение (Слайды 29-30)

Слайд 29: Итоги разработки

Разработано полнофункциональное веб-приложение (MVP).

Реализована сложная логика Kanban с оптимистичным обновлением UI.

Обеспечена безопасность данных и изоляция пользователей.

Архитектура на основе слоев (Nuxt Layers) позволяет легко расширять функционал.

Приложение готово к развертыванию через Docker.

Слайд 30: Планы развития (Roadmap)

WebSockets: Внедрение для мгновенного обновления доски и чата (вместо polling).

PWA: Реализация оффлайн-режима через Service Workers (заготовка в package.json).

Кастомизация: Возможность создавать свои колонки и менять их порядок.

Файлы: Загрузка вложений в задачи (S3-совместимое хранилище).

[ИНФОГРАФИКА: Timeline] Временная шкала: v1.0 (MVP) -> v1.1 (WebSockets) -> v1.2 (PWA/Offline) -> v2.0 (Custom Columns).
