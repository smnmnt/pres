# Slide Tiles для презентации Teamly

## Раздел 1: Введение и Обзор Технологий

### Слайд 1: Титульный
**tile title:**
Teamly — Коллаборативный трекер задач

**tile image:**
[Геройское изображение Kanban-доски с задачами, логотип Teamly в центре, градиентный фон с технологиями]

**tile content:**
Архитектура MVP, реализация Kanban-доски и технические решения.

Проект разработан как SPA (Single Page Application) для управления задачами в малых группах.

Основной фокус разработки: производительность рендеринга, строгая типизация и модульность кода.

Реализован полный цикл CRUD, безопасная аутентификация и real-time взаимодействие через polling (MVP).

Приложение спроектировано с учетом принципов "Desktop-first", но полностью адаптивно.

### Слайд 2: Проблематика и Постановка задачи
**tile title:**
Проблематика и Постановка задачи

**tile image:**
[Таблица сравнения: Enterprise (Jira) vs Teamly. Столбцы: Скорость загрузки, Сложность интерфейса, Настройка прав. С галочками/крестиками показывающими преимущества Teamly]

**tile content:**
Существующие Enterprise-решения (например, Jira) функционально избыточны для семейных и волонтерских команд.

Требуется инструмент с "нулевым" порогом входа, работающий без сложной настройки воркфлоу.

Необходима строгая изоляция данных: пользователь видит только те доски, куда он приглашен.

Архитектура должна поддерживать масштабирование функционала без переписывания ядра.

### Слайд 3: Технический стек (Frontend)
**tile title:**
Технический стек (Frontend)

**tile image:**
[Ряд логотипов технологий: Vue, Nuxt, Pinia, TypeScript, UnoCSS. Каждый логотип с подписью и стрелками, показывающими взаимодействие]

**tile content:**
Core: Nuxt 3.17 + Vue 3.5 (использование Composition API и <script setup>).

State Management: Pinia + pinia-plugin-persistedstate для сохранения состояния между сессиями.

UI Engine: Нативные CSS Variables для темизации + UnoCSS (подключен через слои).

Drag-and-Drop: Библиотека @formkit/drag-and-drop — минимальный вес бандла.

### Слайд 4: Технический стек (Backend & Data)
**tile title:**
Технический стек (Backend & Data)

**tile image:**
[Схема взаимодействия: Client -> Nitro Server -> Prisma Client -> PostgreSQL Container. Показаны стрелки потока данных]

**tile content:**
Server Engine: Nitro — легковесный сервер, встроенный в Nuxt, с поддержкой экспериментального OpenAPI.

Database: PostgreSQL 16 (в Docker-образе postgres:16-alpine).

ORM: Prisma Client 6.10 для типобезопасных запросов к БД.

Auth: Lucia Auth (v3) — управление сессиями без использования JWT.

### Слайд 5: Инфраструктура и Dev-окружение
**tile title:**
Инфраструктура и Dev-окружение

**tile image:**
[Схема контейнеров: app (порт 3000) <---> внутренняя сеть tracker-net <---> db (порт 5432). Показаны Docker-контейнеры с метками]

**tile content:**
Проект полностью контейнеризирован с помощью Docker Compose.

Оркестрация двух сервисов: app (Nuxt-приложение) и db (PostgreSQL).

Настроен healthcheck для БД: приложение ожидает готовности порта 5432 перед запуском.

Используется multi-stage сборка в Dockerfile для минимизации production-образа (на базе Alpine Linux).

## Раздел 2: Архитектура приложения

### Слайд 6: Модульная архитектура (Nuxt Layers)
**tile title:**
Модульная архитектура (Nuxt Layers)

**tile image:**
[Визуализация "слоеного пирога": Base App <- Core <- Auth <- Board <- Tasks. Каждый слой показан как горизонтальный прямоугольник с надписями]

**tile content:**
Вместо монолита используется архитектура Nuxt Layers для слабого зацепления кода.

Слой layers/core: базовые UI-атомы, глобальные стили и утилиты.

Слой layers/auth: изолированная логика регистрации и сессий.

Слой layers/board: бизнес-логика Kanban-доски.

Слой layers/tasks: управление сущностями задач.

### Слайд 7: Схема Базы Данных (ER-Model)
**tile title:**
Схема Базы Данных (ER-Model)

**tile image:**
[Упрощенная ER-диаграмма: User (1:N) -> Board (1:N) -> Task. Связь M:N через BoardParticipant. Показаны основные поля сущностей]

**tile content:**
Центральные сущности: User, Board, Task.

Связи построены на внешних ключах с каскадным удалением (onDelete: Cascade).

TaskStatus в MVP реализован как Enum для упрощения логики перемещения.

### Слайд 8: Ролевая модель доступа (RBAC)
**tile title:**
Ролевая модель доступа (RBAC)

**tile image:**
[Таблица матрицы доступа. Строки: Owner, Editor, Viewer. Столбцы: Создание задач, Удаление задач, Перемещение, Настройки доски. Галочки/крестики в ячейках]

**tile content:**
Права доступа жестко типизированы через enum BoardRole в Prisma.

Owner: Полный доступ, удаление доски, управление приглашениями.

Editor: Создание, редактирование контента, перемещение задач.

Viewer: Только чтение (Read-only доступ).

### Слайд 9: Реализация Аутентификации
**tile title:**
Реализация Аутентификации

**tile image:**
[Диаграмма последовательности: Post Login -> Validate -> Create Session in DB -> Set Cookie -> Response. Показаны стрелки между компонентами]

**tile content:**
Используется библиотека Lucia Auth (адаптер Prisma).

Отход от stateless JWT в пользу stateful sessions в БД (таблица Session).

Это позволяет администратору принудительно отзывать сессии (разлогинивать пользователей).

Пароли хешируются алгоритмом Argon2 перед записью в базу.

## Раздел 3: Реализация Kanban-доски

### Слайд 10: Модель данных Kanban
**tile title:**
Модель данных Kanban

**tile image:**
[Код из schema.prisma с выделенными частями enum TaskStatusEnum и model Task. Показаны основные поля и связи]

**tile content:**
Статусы задач зафиксированы: todo, in_progress, done.

Это решение принято для MVP, чтобы избежать сложности управления динамическими колонками.

Поле order_index зарезервировано для пользовательской сортировки (vNext).

### Слайд 11: Управление состоянием (Pinia Store)
**tile title:**
Управление состоянием (Pinia Store)

**tile image:**
[Схема State Flow: Raw Data (Backend) -> fetch() -> Transformation Logic -> Pinia State (Columns Array) -> UI Component]

**tile content:**
Стор kanban.store.ts — единый источник правды для UI доски.

Состояние columns хранит массив объектов колонок, каждая содержит массив задач.

Инициализация: метод fetch() делает запрос к API и раскладывает плоский массив задач по статусам.

### Слайд 12: Серверная логика выборки данных
**tile title:**
Серверная логика выборки данных

**tile image:**
[Блок-схема алгоритма: Request -> Auth Check -> ACL Check -> DB Query -> Response / Error 403]

**tile content:**
Эндпоинт: GET /api/board/:id/tasks.

Шаг 1: Проверка сессии пользователя (getUserFromSession).

Шаг 2: Проверка доступа к доске (является ли участником или владельцем).

Шаг 3: Выборка задач с include для подгрузки данных исполнителей.

### Слайд 13: Drag-and-Drop (Frontend)
**tile title:**
Drag-and-Drop (Frontend)

**tile image:**
[Демонстрация интерфейса с задачами, перетаскиваемыми между колонками. Показаны стрелки drag-and-drop жестов]

**tile content:**
Реализация на базе @formkit/drag-and-drop.

Компонент kanban-column.vue выступает как дроп-зона.

Используется реактивная привязка: изменение DOM автоматически обновляет массив dndTasks.

Обработчик onTransfer фиксирует факт переноса задачи между списками.

### Слайд 14: Optimistic UI (Оптимистичные обновления)
**tile title:**
Optimistic UI (Оптимистичные обновления)

**tile image:**
[Код из kanban.store.ts с выделенными комментариями: 1. Локально меняем UI, 2. Шлем запрос, 3. При ошибке - откат]

**tile content:**
Мгновенная реакция интерфейса до получения ответа от сервера.

При событии dragend задача перемещается в локальном сторе.

Фоново отправляется PATCH запрос. Если он падает — состояние откатывается.

### Слайд 15: Компонент Колонки (kanban-column.vue)
**tile title:**
Компонент Колонки (kanban-column.vue)

**tile image:**
[Визуализация колонки с вертикальным списком карточек задач, разделенными линиями. Показан input внизу для создания задач]

**tile content:**
Отвечает за рендеринг вертикального списка карточек.

Принимает проп column с данными (id, title, tasks).

Содержит встроенный input для быстрого создания задач без модальных окон.

Визуально разделен с помощью CSS Grid и псевдоэлементов ::before (вертикальные линии).

### Слайд 16: API создания задачи
**tile title:**
API создания задачи

**tile image:**
[JSON-структура запроса: { title: string, description?: string, priority: enum, board_id: uuid }. Показаны типы данных и обязательность полей]

**tile content:**
Метод: POST /api/task.

Валидация тела запроса через Zod (TaskCreateSchema).

Автоматическая привязка статуса todo.

Связывание с доской через board_id.

### Слайд 17: API обновления (PATCH)
**tile title:**
API обновления (PATCH)

**tile image:**
[Иконка PATCH-запроса с универсальным эндпоинтом /api/task/[id]. Показаны стрелки к различным операциям обновления]

**tile content:**
Универсальный эндпоинт PATCH /api/task/[id] для любых изменений.

Поддерживает частичное обновление (Partial Update).

Используется как для смены текста задачи, так и для переключения статуса (status).

Призма автоматически обновляет поле updated_at.

### Слайд 18: Карточка задачи (task-card.vue)
**tile title:**
Карточка задачи (task-card.vue)

**tile image:**
[Скриншот карточки с выносками: "ID", "Priority Icon", "Title", "Assignees count", "Date". Разные цвета приоритетов]

**tile content:**
Атомарный компонент отображения задачи.

Выводит ID (например, #a3f1), заголовок и бейджи.

Интегрирует компонент PriorityBadge для цветовой кодировки.

Отображает количество исполнителей ("+2 исп.").

### Слайд 19: Система приоритетов
**tile title:**
Система приоритетов

**tile image:**
[Три цветных контейнера: Красный (High), Синий (Medium), Серый (Low) с соответствующими иконками приоритетов]

**tile content:**
Три уровня приоритета: Low, Medium, High.

Реализовано через компонент priority-badge.vue.

Использует семантические цвета дизайн-системы:
High -> Error Container (Красный).
Medium -> Primary Container (Синий).
Low -> Secondary Container (Серый).

### Слайд 20: Работа с датами и локализация
**tile title:**
Работа с датами и локализация

**tile image:**
[Примеры человекочитаемых строк: "5 минут назад", "вчера", "3 дня назад". Фон с русскими склонениями]

**tile content:**
Используется библиотека date-fns для легковесной обработки дат.

Функция formatDistanceToNow создает человекочитаемые строки ("5 минут назад").

Подключена локаль ru для корректных склонений.

Это повышает информативность интерфейса без перегрузки точными датами.

## Раздел 4: Дополнительные функции

### Слайд 21: Реализация Чата (MVP)
**tile title:**
Реализация Чата (MVP)

**tile image:**
[Схема цикла: Client --(GET /chat)--> Server; (wait 5s); Client --(GET /chat)--> Server. Показан повторяющийся цикл]

**tile content:**
Чат привязан к конкретной доске (Board -> Conversation -> Message).

Вместо WebSockets используется Short Polling (опрос раз в 5 сек).

Это упрощает деплоймент и инфраструктуру на старте проекта.

Поддержка упоминаний @all (реализовано регулярным выражением на бэкенде).

### Слайд 22: Приглашения и QR-коды
**tile title:**
Приглашения и QR-коды

**tile image:**
[QR-код на экране смартфона, направленный на доску Teamly. Показаны параметры ссылки: роль, лимит, срок действия]

**tile content:**
Таблица InvitationLink хранит токены доступа.

Параметры ссылки: роль (viewer/editor), лимит использований, срок действия.

Генерация QR-кода происходит на клиенте с помощью qrcode.vue.

Удобно для быстрого подключения мобильных устройств к доске.

### Слайд 23: Регистрация и Онбординг
**tile title:**
Регистрация и Онбординг

**tile image:**
[Форма регистрации с автоматическим заполнением display_name из email. Показана стрелка "автоматический вход"]

**tile content:**
Форма регистрации валидируется на клиенте и сервере.

Автоматическая генерация display_name из email, если поле не заполнено.

UX-паттерн: автоматический вход (создание сессии) сразу после регистрации.

Пользователю не нужно вводить логин/пароль повторно.

### Слайд 24: Дизайн-система и Токены
**tile title:**
Дизайн-система и Токены

**tile image:**
[Визуализация цветовой палитры (Light/Dark mode) и шкалы отступов. Показаны переменные: --clr-primary, --sp-m, --cr-l]

**tile content:**
Используются CSS Custom Properties для глобальной настройки.

Определены токены для: цветов (--clr-primary), отступов (--sp-m), скруглений (--cr-l).

Базовые компоненты (TeamlyButton, TeamlyInput) строятся на этих токенах.

### Слайд 25: Адаптивность и Layout
**tile title:**
Адаптивность и Layout

**tile image:**
[Макет страницы с CSS Grid: сайдбары фиксированной ширины на десктопе, скрытые на мобильных. Основной контент с горизонтальным скроллом]

**tile content:**
Используется CSS Grid для каркаса страницы (layout.css).

Переменные брейкпоинтов: --bp-m: 768px.

Сайдбары имеют фиксированную ширину на десктопе, на мобильных скрываются.

Основной контент (доска) имеет горизонтальный скролл на малых экранах.

## Раздел 5: Безопасность и Развертывание

### Слайд 26: Валидация данных (Zod)
**tile title:**
Валидация данных (Zod)

**tile image:**
[Код схемы Zod: const BoardCreateSchema = z.object({ title: z.string().min(1).max(120), visibility: z.enum(["private", "link", "public"]) });]

**tile content:**
Используется библиотека Zod для декларирования схем данных.

Валидация происходит в API-хендлерах перед обращением к БД.

Гарантирует, что в базу попадут только корректные типы данных.

### Слайд 27: Защита и Middleware
**tile title:**
Защита и Middleware

**tile image:**
[Схема защиты: Client (middleware) -> Server (getUserFromSession) -> ACL Check -> 403 Forbidden. Показаны уровни защиты]

**tile content:**
Клиент: Глобальный middleware проверяет состояние авторизации.

Сервер: Утилита getUserFromSession(event) извлекает пользователя из cookie.

ACL: Проверка прав доступа к ресурсу (например, проверка owner_user_id при удалении доски).

При отсутствии прав возвращается стандартный 403 Forbidden.

### Слайд 28: Docker Compose Конфигурация
**tile title:**
Docker Compose Конфигурация

**tile image:**
[Схема: Host Machine -> Docker Engine -> [App Container] + [DB Container] (Volume). Показаны сервисы и зависимости]

**tile content:**
Файл docker-compose.yml описывает сервисы.

Сервис app: сборка из Dockerfile, проброс порта 3000.

Сервис db: официальный образ postgres:16-alpine.

Использование depends_on с condition: service_healthy для правильного порядка запуска.

## Раздел 6: Заключение

### Слайд 29: Итоги разработки
**tile title:**
Итоги разработки

**tile image:**
[Иконки достижений: чекмарки для каждого пункта. Фон с градиентом успеха]

**tile content:**
Разработано полнофункциональное веб-приложение (MVP).

Реализована сложная логика Kanban с оптимистичным обновлением UI.

Обеспечена безопасность данных и изоляция пользователей.

Архитектура на основе слоев (Nuxt Layers) позволяет легко расширять функционал.

Приложение готово к развертыванию через Docker.

### Слайд 30: Планы развития (Roadmap)
**tile title:**
Планы развития (Roadmap)

**tile image:**
[Временная шкала: v1.0 (MVP) -> v1.1 (WebSockets) -> v1.2 (PWA/Offline) -> v2.0 (Custom Columns). Иконки для каждой версии]

**tile content:**
WebSockets: Внедрение для мгновенного обновления доски и чата (вместо polling).

PWA: Реализация оффлайн-режима через Service Workers (заготовка в package.json).

Кастомизация: Возможность создавать свои колонки и менять их порядок.

Файлы: Загрузка вложений в задачи (S3-совместимое хранилище).
